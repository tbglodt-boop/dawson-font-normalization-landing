<!-- index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dawson — Deterministic Font → SVG Geometry</title>

  <!-- Google-hosted Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;600;700&display=swap" rel="stylesheet" />

  <!-- Sidecar CSS (this is the correct way; <style href=...> is not a thing) -->
  <link rel="stylesheet" href="css/style.css?v=20260221-1405" />
</head>

<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <header class="site-header">
    <div class="container">
      <div class="nav-panel">
        <nav class="nav" aria-label="Primary">
          <a class="brand" href="#" aria-label="Dawson Creative Labs">
              <img class="brand-logo" src="assets/svg/DAWSON_creative_labs.svg" alt="Dawson Creative Labs"/>
          </a>

          <ul class="nav-links">
            <li><a class="nav-link" href="#examples">Examples</a></li>
            <li><a class="nav-link" href="#faq">FAQ</a></li>
            <li><a class="nav-link" href="#contact">Contact</a></li>
          </ul>

          <a class="btn btn-dark btn-wide nav-cta" href="#">Start</a>
        </nav>
      </div>
    </div>
  </header>

  <main id="main">
    <!-- HERO -->
    <section class="section">
      <div class="container">
        <div class="panel hero">
          <div class="hero-copy">
            <h1>Deterministic Font → SVG Geometry.<br /><span>No Clipping. No Baseline Math. No runtime offsets.</span></h1>

            <p>
              We convert traditional fonts into stable, standalone SVG symbol libraries.
              Every glyph starts at a real (0,0), uses explicit bounds, and ships with production-safe padding.
              Use them in CAD, UI systems, or procedural layouts without offsets or debugging guesswork.
            </p>

            <hr class="rule" />

            <ul class="bullets">
              <li>True (0,0) origin + non-negative coordinate space</li>
              <li>Three engineered outputs: CORE → SAFE → DECK</li>
              <li>Includes contact sheets, metadata manifest, and SAFE master defs library</li>
            </ul>

            <div class="cta-row">
              <a class="btn" href="#">Start a $50 Pass</a>
              <a class="btn btn-dark" href="#">Download a Sample</a>
            </div>

            <div class="pill-row">
              <span class="pill">Turnaround</span>
              <span class="pill">Outputs</span>
              <span class="pill">Refund terms</span>
            </div>

            <p class="microtrust">
              Built for real renderers. SAFE padding tuned to survive rasterization and rounding.
            </p>
          </div>

          <aside class="hero-visual" aria-label="Hero visual proof">
            <div class="hero-proof">
              <img
                class="hero-graphic"
                src="assets/svg/hero__safe-glyph-demo__uc-H__rev-A.svg"
                alt="SAFE glyph H showing true (0,0) origin and padding inset"
              />
            </div>
          </aside>
        </div>
      </div>
    </section>

    <!-- EXAMPLES -->
    <section id="examples" class="section">
      <div class="container">
        <div class="panel">
          <div class="section-head">
            <h2>Examples</h2>
            <p class="subhead">Standard Font Export vs Deterministic Geometry</p>
          </div>

          <div class="examples-grid">
            <div class="example example-dark">
              <div class="example-label">
                <h3>Typical Font Export</h3>
                <p class="small">
                  Arbitrary Coordinate Space<br />
                  viewBox: guessed / inferred<br />
                  -2000 -2000 6000 6000<br />
                  Contains negative coordinates
                </p>
              </div>
              <div class="example-body">
                <img class="example-graphic" src="assets/svg/example__before__converter-fail__glyph-R__guessed-viewbox__900__rev-D.svg" alt="Typical font exporter output: guessed viewBox, floating glyph, inferred bounds" />
              </div>
            </div>

            <div class="example example-dark">
              <div class="example-label">
                <h3>Dawson Normalized Font</h3>
                <p class="small">
                  Deterministic Coordinate Space<br />
                  viewBox: script-defined (SAFE)<br />
                  0 0 1265 1502<br />
                  Non-negative coordinate space
                </p>
              </div>
              <div class="example-body">
                <img class="example-graphic" src="assets/svg/panel__example__dawfont__glyph-R__normalized__900__rev-A.svg" alt="Dawson Normalized Font: Calculated viewBox with known bounds, Explicit Origin Aligned Geometry" />
              </div>
            </div>
          </div>

          <div class="cta-row cta-row-wide">
            <a class="pill" href="#">Download Sample</a>
            <a class="btn btn-dark" href="#">Start Now</a>
          </div>
        </div>
      </div>
    </section>

    <!-- WHAT YOU GET -->
    <section class="section">
      <div class="container">
        <div class="panel panel_two">
          <div class="wyg-layout">
            <!-- LEFT COLUMN -->
            <div class="wyg-left">
              <div class="section-head">
                <h2>What You Get</h2>
                <p class="subhead">
                  Not a raw export dump. You get a deterministic SVG glyph package: predictable, reusable, renderer-safe.
                </p>
              </div>

              <h3 class="kicker">You Receive</h3>

              <div class="deliverables">
                <div class="deliverable"><div class="deliverable-title">01_Core - Tight Geometry</div></div>
                <div class="deliverable"><div class="deliverable-title">02_Safe - Production padding (P=6 default)</div></div>
                <div class="deliverable"><div class="deliverable-title">03_Deck - Shared Tile viewBox</div></div>
                <div class="deliverable"><div class="deliverable-title">Manifest + logs</div></div>
                <div class="deliverable"><div class="deliverable-title">Contact Sheets</div></div>
                <div class="deliverable"><div class="deliverable-title">SAFE_Master_Defs.svg</div></div>
              </div>

              <h3 class="kicker">Engineering Details (For Technical Review)</h3>

              <div class="accordion">
                <details open>
                  <summary>CORE / SAFE / DECK — What Each Set Is For</summary>
                  <div class="accordion-body">
                    <p>You receive three engineered outputs. Same glyphs, three different behaviors—each optimized for a different job.</p>

                    <div class="split">
                      <div>
                        <h4>CORE (Tight Geometry)</h4>
                        <ul>
                          <li>True (0,0) origin</li>
                          <li>No padding</li>
                          <li>Baseline-baked lowercase</li>
                          <li>Use CORE for precision math and boolean workflows</li>
                        </ul>
                        <p class="small">Tight bounds may reveal minor edge clipping in weak renderers.</p>
                      </div>

                      <div>
                        <h4>SAFE (Production Geometry)</h4>
                        <ul>
                          <li>Same geometry as CORE</li>
                          <li>Expanded viewBox padding to prevent edge clipping and rounding artifacts</li>
                          <li>Default P=6</li>
                        </ul>
                        <p class="small">Use SAFE for browsers, export pipelines, and real renderers. This is the default ship set.</p>
                      </div>

                      <div>
                        <h4>DECK (Standardized Tile Geometry)</h4>
                        <ul>
                          <li>Every glyph shares the same viewBox</li>
                          <li>All symbols align consistently as tiles</li>
                        </ul>
                        <p class="small">Use DECK for contact sheets, grids, previews, and uniform placement (“deck of cards” logic).</p>
                      </div>
                    </div>
                  </div>
                </details>

                <details>
                  <summary>Baseline Logic and Lowercase Glyphs</summary>
                  <div class="accordion-body">
                    <h3>Why We Bake the Baseline (Instead of Making You Compute It at Runtime)</h3>
                    <p>Raw font exports use tight bounding boxes.</p>
                    <p>In a typical font:</p>
                    <ul>
                      <li><strong>Uppercase glyphs</strong> sit on the baseline and reach cap height.</li>
                      <li><strong>Lowercase glyphs</strong> sit on the baseline but do not reach cap height.</li>
                    </ul>
                    <p>If you export both with the upper-left at <code>(0,0)</code>:</p>
                    <ul>
                      <li>Uppercase symbols have one height</li>
                      <li>Lowercase symbols have a smaller height</li>
                      <li>Mixed-case placement requires vertical offsets</li>
                      <li>Runtime systems must compute baseline alignment</li>
                    </ul>
                    <p>This introduces:</p>
                    <ul>
                      <li>Conditional logic</li>
                      <li>Y-axis pushing</li>
                      <li>Baseline detection</li>
                      <li>Additional layout math</li>
                      <li>More room for bugs</li>
                    </ul>
                    <hr />
                    <h4>What We Do Instead</h4>
                    <p>We bake baseline alignment into the geometry during export.</p>
                    <p>For lowercase glyphs:</p>
                    <ol>
                      <li>
                        We calculate the baseline target using a stable uppercase reference
                        (<code>H</code>, <code>E</code>, or a fallback percentile).
                      </li>
                      <li>
                        We add <strong>top padding</strong> equal to the difference between the lowercase glyph height and the baseline target.
                      </li>
                      <li>
                        We normalize coordinates so all glyphs share a consistent vertical relationship.
                      </li>
                    </ol>
                    <p><strong>Result:</strong></p>
                    <ul>
                      <li>No runtime baseline math</li>
                      <li>No conditional alignment logic</li>
                      <li>No Y-offset calculations</li>
                      <li>No interpretation of font metrics at placement time</li>
                    </ul>
                    <p>All symbols drop into layout aligned by default.</p>
                    <hr />
                    <h4>Why This Is Better</h4>
                    <ol>
                      <li>
                        <strong>Determinism</strong>
                        <p>Every glyph has:</p>
                        <ul>
                          <li>A predictable origin</li>
                          <li>A consistent baseline relationship</li>
                          <li>Precomputed vertical alignment</li>
                        </ul>
                        <p>The runtime does not need to interpret typography. It only places geometry.</p>
                      </li>
                      <li>
                        <strong>Minimal Runtime Math</strong>
                        <p>Without baked baseline:</p>
                        <pre><code>if lowercase:
  y_offset = baseline_target - glyph_height
else:
  y_offset = 0</code></pre>

                        <p>With baked baseline:</p>
                        <pre><code>place(symbol)</code></pre>

                        <p>That is the difference.</p>
                      </li>

                      <li>
                        <strong>Runtime Simplicity</strong>
                        <p>Layout engines should position objects. They should not reinterpret font metrics.</p>
                        <p>Baseline logic at runtime:</p>
                        <ul>
                          <li>Must be calculated</li>
                          <li>Must be tested</li>
                          <li>Must be maintained</li>
                          <li>Can fail in edge cases</li>
                        </ul>
                        <p>Baked geometry eliminates that surface area entirely.</p>
                      </li>

                      <li>
                        <strong>Reduced Cognitive Load</strong>
                        <p>Engineers using the exported symbols do not need to:</p>
                        <ul>
                          <li>Understand ascenders/descenders</li>
                          <li>Compute cap height</li>
                          <li>Determine baseline shifts</li>
                          <li>Handle mixed-case alignment logic</li>
                        </ul>
                        <p>The geometry already behaves correctly.</p>
                      </li>

                      <li>
                        <strong>Cross-System Stability</strong>
                        <p>Different environments handle vertical alignment differently:</p>
                        <ul>
                          <li>SVG renderers</li>
                          <li>CSS layout engines</li>
                          <li>GPU rasterization</li>
                          <li>Browser baseline rules</li>
                        </ul>
                        <p>Pre-normalized glyph geometry avoids cross-environment inconsistencies.</p>
                        <p>The symbol contains its alignment.</p>
                      </li>
                    </ol>

                    <hr />

                    <h4>Important Clarification</h4>

                    <p>The lowercase letterforms are not modified.</p>
                    <p><strong>Only the bounding geometry is normalized.</strong></p>

                    <ul>
                      <li>We standardize coordinate space.</li>
                      <li>We do not alter the design.</li>
                    </ul>
                  </div>
                </details>

                <details>
                  <summary>SAFE Unit Padding — Why P=6 (Not 2)</summary>
                  <div class="accordion-body">
                    <p><strong>Because 2 units is theoretically sufficient and 6 units is operationally reliable.</strong></p>
                    <h3>What is a “Safe Unit”?</h3>
                    <p>
                      A Safe Unit is padding added to the exported SVG symbol’s bounding box.
                    </p>
                    <p>
                      It does not alter glyph geometry.<br />
                      It does not affect kerning.<br />
                      It does not change advance width.
                    </p>
                    <p>
                      It prevents edge clipping and renderer rounding artifacts.
                    </p>
                    <h3>Why isn’t 2 units enough?</h3>
                    <p>Most modern fonts use:</p>
                    <ul>
                      <li><strong>UPM = 2048 units</strong></li>
                    </ul>
                    <p>With that grid:</p>
                    <ul>
                      <li>2 units = 0.097% of em</li>
                      <li>At 100px render size ≈ 0.097 pixels</li>
                    </ul>
                    <p>
                      That is below the threshold of many rasterization rounding behaviors.
                    </p>
                    <p>In real-world rendering, this can fail under:</p>
                    <ul>
                      <li>browser subpixel rounding</li>
                      <li>GPU antialiasing</li>
                      <li>stroke expansion</li>
                      <li>CSS transforms</li>
                      <li><code>&lt;use&gt;</code> instancing</li>
                      <li>viewBox scaling</li>
                      <li>fractional layout math</li>
                    </ul>
                    <p>
                      2 units works in controlled math.<br />
                      It does not always survive uncontrolled rendering environments.
                    </p>
                    <h3>Why 6 units?</h3>
                    <p>6 units = 0.293% of em.</p>
                    <p>Still extremely small.</p>
                    <p>But it:</p>
                    <ul>
                      <li>survives subpixel rounding</li>
                      <li>provides margin for stroke expansion</li>
                      <li>prevents tight-bound clipping</li>
                      <li>holds up under browser inconsistencies</li>
                      <li>remains visually negligible</li>
                    </ul>
                    <p>
                      6 units is the smallest value that consistently behaves well across renderers.
                    </p>
                    <h3>Does 6 units change layout?</h3>
                    <p>No.</p>
                    <p>Padding exists inside the SVG <code>viewBox</code> only.</p>
                    <p>It does not modify:</p>
                    <ul>
                      <li>advance width</li>
                      <li>kerning</li>
                      <li>glyph proportions</li>
                      <li>baseline math</li>
                    </ul>
                    <p>
                      It simply ensures the glyph does not sit on the bounding edge.
                    </p>
                    <h3>Why not 8 or 12?</h3>
                    <p>You could.</p>
                    <p>
                      We tested lower values to determine the minimum safe margin.
                    </p>
                    <p>6 units is:</p>
                    <ul>
                      <li>conservative</li>
                      <li>minimal</li>
                      <li>stable</li>
                      <li>not wasteful</li>
                    </ul>
                    <p>
                      Higher values add safety but are unnecessary for typical workflows.
                    </p>
                  </div>
                </details>

                <details>
                  <summary>Engineering Manifest (Run Metadata)</summary>
                  <div class="accordion-body">
                    <p>Each normalization run ships with a structured JSON manifest describing the source font, engineering metrics, baseline logic, padding strategy, glyph counts, and DECK bounding dimensions.</p>
                    <p>This file acts as a reproducible contract between the source font and the exported geometry. No hidden transforms. No inferred values. All baseline and coordinate decisions are explicit.</p>
                    <pre><code>{
  "namespace": "dawfont-inter-black",
  "foundry": "dawfont",
  "family": "inter",
  "style": "black",
  "font_path": "00_Source_Font\\Inter_24pt-black.ttf",
  "padding_P": 6.0,
  "engineering_metrics": {
    "units_per_em": 2048,
    "ascent": 1984,
    "descent": -494,
    "line_gap": 0,
    "cap_height": 1490,
    "x_height": 1084
  },
  "baseline_target_mode": "A_ref_H_else_E_else_0_else_p90_caps_digits",
  "baseline_reference": "u0048",
  "baseline_target_ymax_font_units": 1490.0,
  "counts": {
    "drawable_glyphs": 2830,
    "written_core": 2830,
    "written_safe": 2830,
    "written_deck": 2830,
    "id_collisions_detected": 0
  },
  "deck_box": {
    "width": 5046.0,
    "height": 2810.0,
    "based_on": "SAFE_max_dims"
  },
  "notes": [
    "All outputs are SYMBOL-ONLY, one-line, no paint, no transforms.",
    "All coordinates are baked and non-negative in CORE/SAFE/DECK.",
    "Lowercase baseline bake applies to Unicode category Ll (all lowercase letters)."
  ]
}</code></pre>
                  </div>
                </details>

                <details>
                  <summary>Test_Rigs — Visual Proof &amp; Verification Pages</summary>
                  <div class="accordion-body">
                    <p>We ship proof pages so you can visually confirm stability: contact sheets, clipping checks, alignment checks, deterministic ordering so pages don’t reshuffle between runs.</p>
                  </div>
                </details>

                <details>
                  <summary>Find What You Need in Seconds (Even with 2,800+ Glyphs)</summary>
                  <div class="accordion-body">
                    <p>Every Dawson export may contain thousands of glyphs.</p>
                    <p>That is not noise. That is value.</p>
                    <p>
                      You receive full Unicode coverage from the source font — not just the English alphabet.
                      But the naming system is engineered so the characters you actually use every day rise to the top automatically.
                    </p>
                    <ul>
                      <li>No digging</li>
                      <li>No memorizing Unicode charts</li>
                      <li>No guessing</li>
                    </ul>
                    <hr />
                    <h4>How the Glyphs Are Organized</h4>
                    <p>
                      Each glyph name is intentionally prefixed for human-first sorting.
                      Sort order is built into the filename.
                    </p>
                    <p>You will see this structure:</p>
                    <dl>
                      <dt><code>00-</code></dt>
                      <dd>Digits (0–9)</dd>
                      <dt><code>10-</code></dt>
                      <dd>Uppercase A–Z</dd>
                      <dt><code>20-</code></dt>
                      <dd>Lowercase a–z</dd>
                      <dt><code>30-</code></dt>
                      <dd>Common ASCII punctuation</dd>
                      <dt><code>90-</code></dt>
                      <dd>Extended Unicode</dd>
                    </dl>
                    <p>That means when you open the folder and sort alphabetically:</p>
                    <ul>
                      <li>Numbers are first</li>
                      <li>Then A–Z</li>
                      <li>Then a–z</li>
                      <li>Then symbols</li>
                      <li>Then everything else</li>
                    </ul>
                    <p>Your everyday English character set is always at the front of the stack.</p>
                    <hr />
                    <h4>Example Filenames</h4>
                    <p>SAFE set examples:</p>
                    <pre><code>dawfont-inter-black__safe__00-d-0__u0030.symbol.svg
dawfont-inter-black__safe__10-uc-A__u0041.symbol.svg
dawfont-inter-black__safe__20-lc-a__u0061.symbol.svg
dawfont-inter-black__safe__30-sym-period__u002e.symbol.svg</code></pre>
                    <p>You do not need to know Unicode.</p>
                    <p>You do not need to reference ASCII charts.</p>
                    <p>The names are readable.</p>
                    <hr />
                    <h4>Why This Matters</h4>
                    <p>Most font-to-SVG exports dump glyphs in raw Unicode order. That means:</p>
                    <ul>
                      <li>Uppercase scattered</li>
                      <li>Lowercase buried</li>
                      <li>Symbols unpredictable</li>
                      <li>Thousands of glyphs with no human sorting logic</li>
                    </ul>
                    <p>Dawson does not rely on Unicode ordering for usability. We impose a human ordering layer.</p>
                    <p>This makes:</p>
                    <ul>
                      <li>File browsing faster</li>
                      <li>Contact sheets easier to scan</li>
                      <li>Diffs easier to compare</li>
                      <li>Manual integration frictionless</li>
                      <li>Debugging faster</li>
                    </ul>
                    <p>It is designed for engineers who do not want to think about glyph indexing.</p>
                    <hr />
                    <h4>You Still Get Everything</h4>
                    <p>After the English alphabet and symbols, the full Unicode set follows. That means:</p>
                    <ul>
                      <li>Accented characters</li>
                      <li>Extended Latin</li>
                      <li>Currency symbols</li>
                      <li>Mathematical symbols</li>
                      <li>Foreign scripts (if the font includes them)</li>
                      <li>Everything the font provides</li>
                    </ul>
                    <p>You are not getting a subset.</p>
                    <p>You are getting full coverage — just organized intelligently.</p>
                    <hr />
                    <h4>Plug and Play</h4>
                    <ol>
                      <li>Open the folder.</li>
                      <li>Sort by name.</li>
                      <li>Use what you need.</li>
                    </ol>
                    <p>No configuration. No mapping tables. No metadata parsing. No runtime indexing.</p>
                    <p>Designed for:</p>
                    <ul>
                      <li>Low friction</li>
                      <li>Deterministic access</li>
                      <li>Zero guesswork</li>
                    </ul>
                    <p>We thought about how engineers actually browse files — and we built for that behavior.</p>
                    <hr />
                    <h4>Summary</h4>
                    <p>You receive:</p>
                    <ul>
                      <li>Thousands of glyphs</li>
                      <li>Full Unicode coverage</li>
                      <li>Human-first sort ordering</li>
                      <li>Readable filenames</li>
                      <li>Deterministic structure</li>
                      <li>Zero runtime lookup requirements</li>
                    </ul>
                    <p>
                      Numbers first. A–Z next. a–z after that. Symbols immediately visible. Everything else preserved.
                    </p>
                    <p>It just works.</p>
                  </div>
                </details>

                <details>
                  <summary>Why Dawson Uses &lt;symbol&gt; (Not &lt;g&gt; or Raw Paths)</summary>
                  <div class="accordion-body">
                    <p>&lt;symbol&gt; gives each glyph an isolated viewport (viewBox) and clean instancing via &lt;use&gt;—no transforms, no context-dependent scaling math.</p>
                  </div>
                </details><!-- keep your <details> blocks exactly as-is in here -->
              </div>
            </div>

            <!-- RIGHT COLUMN -->
            <aside class="wyg-right">
              <div class="card card-dark bottom_ten">
                <div class="price">$50 Pass</div>
                <div class="card-lines">
                  <div style = "text-align: center; font-weight:600;">Includes: CORE / SAFE / DECK</div>
                  <div style = "text-align: center; margin:10px 0; font-weight:600;">+ Meta manifest + Test_Rigs + Contact Sheets + SAFE_Master_Defs.svg</div>
                </div>
                <a class="btn w_hundred" href="#">Buy / Start</a>
                <div style = "text-align: center; margin:10px 0; font-weight:600;" class="small_trust">Secure checkout. One-time $50 fee. No subscription required.</div>
              </div>

              <div class="card">
                <h3 class="kicker">Safe Set — Baseline Behavior</h3>
                <div class="baseline-demo" aria-hidden="true">
                  <img
                    class="hero-graphic"
                    src="assets/svg/baseline__rigs__example__HEexpy__rev-A.svg"
                    alt="SAFE glyph H showing true (0,0) origin and padding inset"
                  />
                </div>
                <p class="small">Uppercase and lowercase share baked baseline alignment. No runtime offset required.</p>
                <a class="pill" href="#">View at Full Scale</a>
              </div>
            </aside>
          </div> <!-- .wyg-layout -->
        </div>   <!-- .panel -->
      </div>     <!-- .container -->
    </section>

    <!-- HOW IT WORKS -->
    <section class="section">
      <div class="container">
        <div class="panel">
          <div class="section-head">
            <h2>How it works</h2>
            <p class="subhead">3-step flow: Pay → Upload → Deliver</p>
          </div>

          <div class="cards-3">
            <article class="card">
              <h3>Submit Font</h3>
              <ul class="bullets">
                <li>Upload .ttf or .otf</li>
                <li>Select SAFE padding (default P=6)</li>
                <li>Optional: custom padding target</li>
              </ul>
              <p class="small">Font metrics are analyzed. No geometry is altered.</p>
            </article>

            <article class="card">
              <h3>Deterministic Normalization</h3>
              <ul class="bullets">
                <li>Extract glyph outlines</li>
                <li>Bake baseline alignment</li>
                <li>Normalize to (0,0) origin</li>
                <li>Generate CORE / SAFE / DECK sets</li>
                <li>Deterministic naming + ordering</li>
                <li>Manifest + audit notes</li>
              </ul>
              <p class="small">All coordinates are baked. No transforms. No paint. No runtime math.</p>
            </article>

            <article class="card">
              <h3>Structured Output Package</h3>
              <ul class="bullets">
                <li>3 glyph sets (CORE / SAFE / DECK)</li>
                <li>Metadata + manifest.json</li>
                <li>Contact sheets + visual test rigs</li>
                <li>SAFE_Master_Defs.svg</li>
              </ul>
              <p class="small">Delivered as a structured ZIP package. Stable across runs.</p>
            </article>
          </div>

          <div class="cta-row cta-row-wide">
            <a class="pill" href="#">Download Sample</a>
            <a class="btn btn-dark" href="#">Start now</a>
          </div>
        </div>
      </div>
    </section>

    <!-- FAQ -->
    <section id="faq" class="section">
      <div class="container">
        <div class="panel">
          <div class="section-head">
            <h2>FAQ</h2>
            <p class="subhead">Answer objections: time, licensing, formats, refunds, deliverables</p>
          </div>

          <div class="accordion">
            <details>
              <summary>Why Lowercase Isn’t Tight-Bounded Like Uppercase</summary>
              <div class="accordion-body">
                <p><strong>Because tight lowercase bounds create runtime baseline math.</strong></p>
                <p>Tight lowercase bounds mean:</p>
                <ul>
                  <li>different symbol heights</li>
                  <li>required Y-axis adjustments</li>
                  <li>context-dependent placement logic</li>
                </ul>
                <p>
                  If each lowercase glyph has a different top boundary,
                  layout systems must calculate offsets at runtime to align them.
                </p>
                <p>We bake baseline alignment into the export so that:</p>
                <ul>
                  <li>all glyphs share a consistent vertical reference</li>
                  <li>no Y-offset calculation is required</li>
                  <li>mixed-case alignment works immediately</li>
                </ul>
                <p>
                  The geometry is corrected once — during export — instead of repeatedly at runtime.
                </p>
              </div>
            </details>

            <details>
              <summary>How is this different from a free TTF → SVG converter?</summary>
              <div class="accordion-body">
                <p><strong>Most “TTF → SVG converters” do not output engineered geometry.</strong> They output a <em>typesetting artifact</em>.</p>
                <p>What you usually get is an <strong>SVG font container</strong> (old SVG Fonts spec):</p>
                <pre><code>&lt;svg&gt;
  &lt;defs&gt;
    &lt;font&gt;
      &lt;font-face /&gt;
      &lt;missing-glyph /&gt;
      &lt;glyph /&gt;
      &lt;glyph /&gt;
        ...
      &lt;hkern /&gt;
    &lt;/font&gt;
  &lt;/defs&gt;
&lt;/svg&gt;</code></pre>
                <p>
                  That means it’s <strong>not</strong> “one glyph = one SVG asset,” and it’s not immediately usable as a
                  <code>&lt;defs&gt;</code> library of symbols. You’re expected to think like a font parser.
                </p>
                <hr />
                <ol>
                  <li>
                    <p><strong>SVG font format is a dead end for many engines</strong></p>
                    <p>
                      The <code>&lt;font&gt;</code>/<code>&lt;glyph&gt;</code>/<code>&lt;hkern&gt;</code> model is the legacy SVG Fonts spec and is
                      widely unsupported in modern renderers and tooling. Many consumers only support normal SVG geometry
                      (<code>&lt;path&gt;</code>, <code>&lt;g&gt;</code>, <code>&lt;symbol&gt;</code>, etc.), not embedded font tables.
                    </p>
                    <p><strong>Result:</strong> you still end up writing extraction logic to reconstruct glyph assets.</p>
                  </li>
                  <li>
                    <p><strong>Monolithic output (bloat + terrible diffability)</strong></p>
                    <p>
                      Typical exports dump <em>everything</em> into one file: thousands of glyph nodes plus kerning tables.
                      This is hostile to version control diffs, caching, partial updates, and “only ship what I need” workflows.
                    </p>
                    <p><strong>Dawson approach:</strong> per-glyph assets with deterministic naming and deterministic ordering.</p>
                  </li>
                  <li>
                    <p><strong>The coordinate system is typesetting-first, not geometry-first</strong></p>
                    <p>
                      Fonts commonly include negative descents and global bounding boxes that span negative space.
                      Baseline behavior is implied by font metrics, not baked into the geometry.
                    </p>
                    <p><strong>Engineering pain:</strong> if you’re not running a full typesetter, you now own baseline alignment and normalization.</p>
                    <p><strong>Dawson approach:</strong> baseline baked (for lowercase), intentional origin choice, and non-negative coordinate space in outputs.</p>
                  </li>
                  <li>
                    <p><strong>Global bbox metadata is not a trustworthy placement box</strong></p>
                    <p>
                      A single extreme glyph (arrows, math symbols, emoji, etc.) can include coordinates far outside the
                      font’s stated bbox. That poisons bbox assumptions and makes glyphs look like tiny specks floating
                      in a massive empty viewBox (“glyph in no man’s land”).
                    </p>
                    <p><strong>Dawson approach:</strong> each glyph gets an explicit per-glyph viewBox derived from its actual bounds (CORE/SAFE/DECK rules).</p>
                  </li>
                  <li>
                    <p><strong>No per-glyph viewBox (so you can’t trust the canvas)</strong></p>
                    <p>
                      In SVG font exports, <code>&lt;glyph&gt;</code> usually provides a path <code>d</code> and maybe Unicode/advance width,
                      but there’s no per-glyph viewBox. So every downstream consumer must compute bounds, choose padding,
                      and author a viewBox anyway.
                    </p>
                    <p><strong>Dawson approach:</strong> every glyph ships as a <code>&lt;symbol&gt;</code> with a deterministic viewBox (and SAFE padding when needed).</p>
                  </li>
                  <li>
                    <p><strong>Advance width leaks typesetting concepts into geometry workflows</strong></p>
                    <p>
                      Advance width is a font layout concept, not a geometry bounds concept. If you use it as width, your boxes are wrong.
                      If you ignore it, text spacing logic breaks. Either way, it’s a distraction when your goal is reusable geometry.
                    </p>
                    <p><strong>Dawson approach:</strong> geometry bounds are explicit; any metrics live in sidecar metadata (manifest) you can use or ignore.</p>
                  </li>
                  <li>
                    <p><strong>Unicode lookup becomes a “wasted afternoon” problem</strong></p>
                    <p>
                      Glyph naming is inconsistent (<code>A</code> vs <code>uni27FA</code> vs <code>rightLongArrow2</code>), some glyphs have no Unicode,
                      and coverage ranges can be huge. Extracting “the glyph I want” becomes a hunt.
                    </p>
                    <p><strong>Dawson approach:</strong> deterministic IDs that encode font identity + set + tag + Unicode in a consistent, searchable way.</p>
                  </li>
                  <li>
                    <p><strong>Kerning tables dumped into the same asset (no modularity)</strong></p>
                    <p>
                      Many converters include kerning tables in the same file. If you don’t need kerning (common in CAD/icon/procedural use),
                      you still pay file size and parse cost. If you do need kerning, you must implement the behavior.
                    </p>
                    <p><strong>Dawson approach:</strong> geometry outputs are clean and paintless; metrics live in explicit sidecar data.</p>
                  </li>
                  <li>
                    <p><strong>Legacy wrappers and DTD noise</strong></p>
                    <p>
                      Some exports include old SVG 1.1 DOCTYPE/DTD declarations. In hardened environments, external DTDs can be blocked.
                      Best case it’s noise; worst case it’s a parsing snag.
                    </p>
                    <p><strong>Dawson approach:</strong> minimal, modern SVG meant to be consumed as data assets.</p>
                  </li>
                </ol>
                <hr />
                <h4>The bottom line</h4>
                <p><strong>Traditional converters output typesetting artifacts.</strong></p>
                <ul>
                  <li>monolithic SVG font containers</li>
                  <li>baseline implied, not baked</li>
                  <li>negative coordinate space and bbox confusion</li>
                  <li>no per-glyph viewBox</li>
                  <li>mixed naming and Unicode hunting</li>
                  <li>kerning dumps</li>
                </ul>
                <p><strong>Dawson outputs engineered geometry assets.</strong></p>
                <ul>
                  <li>one glyph = one <code>&lt;symbol&gt;</code> asset</li>
                  <li>deterministic IDs and deterministic ordering</li>
                  <li>explicit per-glyph viewBox (CORE/SAFE/DECK)</li>
                  <li>SAFE padding designed to survive real renderers</li>
                  <li>baseline baked where it matters (lowercase)</li>
                  <li>manifest + logs for auditability</li>
                </ul>
              </div>
            </details>

            <details>
              <summary>Why do some curved letters look slightly clipped in CORE?</summary>
              <div class="accordion-body">
                <p>
                  CORE exports use <strong>tight, geometry-accurate bounding boxes</strong>.
                  That means the <code>viewBox</code> hugs the actual vector outline as closely as possible.
                </p>
                <p>
                  This is intentional. CORE is designed for deterministic geometry workflows —
                  not for renderer forgiveness.
                </p>
                <hr />
                <h4>What “Tight Bounds” Really Means</h4>
                <p>
                  When a glyph is exported in CORE:
                </p>
                <ul>
                  <li>The bounding box is computed directly from the path geometry.</li>
                  <li>No extra padding is added.</li>
                  <li>The edges of the vector may sit exactly on the viewBox boundary.</li>
                </ul>
                <p>
                  For straight-edged letters like <strong>H</strong> or <strong>E</strong>, this usually renders cleanly.
                </p>
                <p>
                  For curved letters like:
                </p>
                <ul>
                  <li><strong>O</strong></li>
                  <li><strong>C</strong></li>
                  <li><strong>S</strong></li>
                  <li><strong>e</strong></li>
                  <li><strong>o</strong></li>
                </ul>
                <p>
                  The curve may mathematically touch the exact edge of the bounding box.
                </p>
                <p>
                  That is where rendering artifacts can appear.
                </p>
                <hr />
                <h4>Anti-Aliasing and Edge Perception</h4>
                <p>
                  Most renderers apply anti-aliasing. That means they soften edges by blending pixels at the boundary.
                </p>
                <p>
                  When a path sits directly on the viewBox edge:
                </p>
                <ul>
                  <li>Half-pixel blending may be truncated.</li>
                  <li>Edge pixels may be rounded inward.</li>
                  <li>The visual curve can appear “slightly clipped.”</li>
                </ul>
                <p>
                  The geometry is not missing.
                </p>
                <p>
                  The renderer is simply resolving subpixel math at the boundary.
                </p>
                <hr />
                <h4>Subpixel Rounding Behavior</h4>
                <p>
                  SVG rendering pipelines frequently involve:
                </p>
                <ul>
                  <li>Floating point coordinate transforms</li>
                  <li>Device pixel snapping</li>
                  <li>GPU rasterization rounding</li>
                  <li>Fractional layout scaling</li>
                </ul>
                <p>
                  If a curve’s outermost point lands at:
                </p>
                <pre><code>x = 360.0000</code></pre>
                <p>
                  And the viewport width resolves to:
                </p>
                <pre><code>359.5 device pixels</code></pre>
                <p>
                  The anti-alias pass may shave a pixel from the perceived edge.
                </p>
                <p>
                  At certain zoom levels, this can look like clipping.
                </p>
                <p>
                  At other zoom levels, it disappears.
                </p>
                <hr />
                <h4>Overshoot and Optical Illusion</h4>
                <p>
                  Curved glyphs intentionally overshoot flat alignment lines.
                </p>
                <p>
                  For example:
                </p>
                <ul>
                  <li>The bottom of <strong>O</strong> dips slightly below the baseline.</li>
                  <li>The top of <strong>O</strong> rises slightly above cap height.</li>
                </ul>
                <p>
                  This is optical correction in type design.
                </p>
                <p>
                  When tight bounding boxes meet overshoot geometry,
                  the renderer may visually flatten the curve at the boundary.
                </p>
                <p>
                  The outline is still correct.
                  The pixel interpretation may not preserve the overshoot visually at small sizes.
                </p>
                <hr />
                <h4>Scaling and <code>&lt;use&gt;</code> Instancing Effects</h4>
                <p>
                  When a CORE glyph is instantiated with:
                </p>
                <pre><code>&lt;use href="#glyph-id" width="..." height="..." /&gt;</code></pre>
                <p>
                  The browser applies scaling math.
                </p>
                <p>
                  That scaling may produce fractional pixel boundaries.
                </p>
                <p>
                  Combined with:
                </p>
                <ul>
                  <li>CSS transforms</li>
                  <li>Responsive resizing</li>
                  <li>Zooming</li>
                  <li>High-DPI displays</li>
                </ul>
                <p>
                  Edge rounding behavior may vary.
                </p>
                <p>
                  CORE does not compensate for this.
                </p>
                <p>
                  SAFE does.
                </p>
                <hr />
                <h4>Renderer Differences</h4>
                <p>
                  Different engines handle boundary math differently:
                </p>
                <ul>
                  <li>Chromium (Blink)</li>
                  <li>Firefox (Gecko)</li>
                  <li>WebKit</li>
                  <li>GPU-accelerated canvas layers</li>
                  <li>CAD preview panes</li>
                  <li>Embedded SVG viewers</li>
                </ul>
                <p>
                  Some clip strictly at the viewBox edge.
                </p>
                <p>
                  Some expand slightly for anti-aliasing.
                </p>
                <p>
                  Some snap to device pixels early in the pipeline.
                </p>
                <p>
                  CORE exposes these differences because it is mathematically tight.
                </p>
                <hr />
                <h4>This Is Why SAFE Exists</h4>
                <p>
                  SAFE adds controlled padding to the viewBox.
                </p>
                <p>
                  That padding:
                </p>
                <ul>
                  <li>Prevents edge-touching curves</li>
                  <li>Absorbs anti-alias rounding</li>
                  <li>Survives subpixel scaling</li>
                  <li>Reduces clipping artifacts across renderers</li>
                </ul>
                <p>
                  The glyph geometry does not change.
                </p>
                <p>
                  Only the bounding box expands.
                </p>
                <hr />
                <h4>When You Should Use CORE</h4>
                <ul>
                  <li>Boolean operations</li>
                  <li>Precision math workflows</li>
                  <li>CAD pipelines</li>
                  <li>Geometry comparisons</li>
                  <li>Deterministic bounding analysis</li>
                </ul>
                <p>
                  CORE is for systems that value exact math over renderer forgiveness.
                </p>
                <hr />
                <h4>When You Should Use SAFE</h4>
                <ul>
                  <li>Browsers</li>
                  <li>Responsive layouts</li>
                  <li>Icon systems</li>
                  <li>UI components</li>
                  <li>General production rendering</li>
                </ul>
                <p>
                  SAFE is the default shipping set for real-world display environments.
                </p>
                <hr />
                <h4>Important Clarification</h4>
                <p>
                  If a curved glyph appears slightly clipped in CORE:
                </p>
                <ul>
                  <li>The path data is intact.</li>
                  <li>No geometry has been removed.</li>
                  <li>The renderer is resolving a boundary condition.</li>
                </ul>
                <p>
                  Zoom in. The curve is there.
                </p>
                <p>
                  CORE is mathematically tight by design.
                </p>
                <p>
                  SAFE exists for visual tolerance across unpredictable rendering environments.
                </p>
              </div>
            </details>

            <details>
              <summary>Why 6 safe units of padding?</summary>
              <div class="accordion-body">
                <p><strong>Because 2 units is theoretically sufficient and 6 units is operationally reliable.</strong></p>
                <h3>What is a “Safe Unit”?</h3>
                <p>
                  A Safe Unit is padding added to the exported SVG symbol’s bounding box.
                </p>
                <p>
                  It does not alter glyph geometry.<br />
                  It does not affect kerning.<br />
                  It does not change advance width.
                </p>
                <p>
                  It prevents edge clipping and renderer rounding artifacts.
                </p>
                <h3>Why isn’t 2 units enough?</h3>
                <p>Most modern fonts use:</p>
                <ul>
                  <li><strong>UPM = 2048 units</strong></li>
                </ul>
                <p>With that grid:</p>
                <ul>
                  <li>2 units = 0.097% of em</li>
                  <li>At 100px render size ≈ 0.097 pixels</li>
                </ul>
                <p>
                  That is below the threshold of many rasterization rounding behaviors.
                </p>
                <p>In real-world rendering, this can fail under:</p>
                <ul>
                  <li>browser subpixel rounding</li>
                  <li>GPU antialiasing</li>
                  <li>stroke expansion</li>
                  <li>CSS transforms</li>
                  <li><code>&lt;use&gt;</code> instancing</li>
                  <li>viewBox scaling</li>
                  <li>fractional layout math</li>
                </ul>
                <p>
                  2 units works in controlled math.<br />
                  It does not always survive uncontrolled rendering environments.
                </p>
                <h3>Why 6 units?</h3>
                <p>6 units = 0.293% of em.</p>
                <p>Still extremely small.</p>
                <p>But it:</p>
                <ul>
                  <li>survives subpixel rounding</li>
                  <li>provides margin for stroke expansion</li>
                  <li>prevents tight-bound clipping</li>
                  <li>holds up under browser inconsistencies</li>
                  <li>remains visually negligible</li>
                </ul>
                <p>
                  6 units is the smallest value that consistently behaves well across renderers.
                </p>
                <h3>Does 6 units change layout?</h3>
                <p>No.</p>
                <p>Padding exists inside the SVG <code>viewBox</code> only.</p>
                <p>It does not modify:</p>
                <ul>
                  <li>advance width</li>
                  <li>kerning</li>
                  <li>glyph proportions</li>
                  <li>baseline math</li>
                </ul>
                <p>
                  It simply ensures the glyph does not sit on the bounding edge.
                </p>
                <h3>Why not 8 or 12?</h3>
                <p>You could.</p>
                <p>
                  We tested lower values to determine the minimum safe margin.
                </p>
                <p>6 units is:</p>
                <ul>
                  <li>conservative</li>
                  <li>minimal</li>
                  <li>stable</li>
                  <li>not wasteful</li>
                </ul>
                <p>
                  Higher values add safety but are unnecessary for typical workflows.
                </p>
              </div>
            </details>

            <details>
              <summary>Why use &lt;symbol&gt; instead of &lt;g&gt; or plain paths?</summary>
              <div class="accordion-body">
                <p>Dawson exports glyphs as <code>&lt;symbol&gt;</code> elements on purpose.</p>
                <p>This is not stylistic. It is architectural.</p>
                <p>
                  If you are building deterministic SVG systems, icon libraries, or layout engines,
                  <code>&lt;symbol&gt;</code> is the correct container for reusable vector geometry.
                </p>
                <p>Here is why:</p>
                <ol>
                  <li>
                    <p><strong><code>&lt;symbol&gt;</code> is a viewport — <code>&lt;g&gt;</code> is not.</strong></p>
                    <p><code>&lt;symbol&gt;</code> supports its own <code>viewBox</code> — <code>&lt;g&gt;</code> does not.</p>
                    <p>That single difference matters enormously.</p>
                    <p>A <code>&lt;symbol&gt;</code> defines:</p>
                    <ul>
                      <li>its own coordinate system</li>
                      <li>its own bounds</li>
                      <li>its own origin</li>
                      <li>its own scaling behavior when instantiated with <code>&lt;use&gt;</code></li>
                    </ul>
                    <p>
                      A <code>&lt;g&gt;</code> is just a grouping container.
                      It inherits whatever coordinate system it happens to be placed into.
                    </p>
                    <p>Dawson glyphs are engineered so that:</p>
                    <ul>
                      <li>(0,0) is deterministic</li>
                      <li>bounds are baked</li>
                      <li>SAFE padding is intentional</li>
                      <li>DECK boxes are shared and centered</li>
                    </ul>
                    <p>That only works cleanly when each glyph has its own <code>viewBox</code>.</p>
                    <p>That means <code>&lt;symbol&gt;</code>.</p>
                  </li>
                  <li>
                    <p><strong><code>&lt;symbol&gt;</code> + <code>&lt;use&gt;</code> = instanceable geometry</strong></p>
                    <p>The purpose of this export system is reuse. When you use:</p>
                    <pre><code>&lt;use href="#glyph-id" width="..." height="..." /&gt;</code></pre>
                    <p>You are instancing a defined viewport. This provides:</p>
                    <ul>
                      <li>clean scaling</li>
                      <li>clean positioning</li>
                      <li>no geometry duplication</li>
                      <li>reduced DOM weight</li>
                      <li>centralized definitions in <code>&lt;defs&gt;</code></li>
                    </ul>
                    <p>That is how production icon systems are structured.</p>
                    <p>
                      A <code>&lt;g id="..."&gt;</code> does not scale with <code>width</code>/<code>height</code>.
                      You would have to apply transforms manually.
                      That reintroduces runtime math — which this system is explicitly designed to eliminate.
                    </p>
                  </li>
                  <li>
                    <p><strong>Deterministic layout requires encapsulation</strong></p>
                    <p>Dawson glyphs bake:</p>
                    <ul>
                      <li>baseline alignment</li>
                      <li>Y-axis inversion</li>
                      <li>SAFE padding</li>
                      <li>centered DECK layout</li>
                    </ul>
                    <p>All of that is geometry-level logic.</p>
                    <p>
                      <code>&lt;symbol&gt;</code> allows each glyph to be a fully self-contained unit.
                      Drop it anywhere. Scale it. Instance it. It behaves the same every time.
                    </p>
                    <p>
                      A <code>&lt;path id="..."&gt;</code> inside a random SVG does not guarantee that.
                      Encapsulation is the point.
                    </p>
                  </li>
                  <li>
                    <p><strong>This is not a font replacement — it’s a geometry system</strong></p>
                    <p>Traditional font glyphs are:</p>
                    <ul>
                      <li>dependent on font metrics</li>
                      <li>dependent on runtime baseline logic</li>
                      <li>dependent on layout engines</li>
                      <li>subject to hinting and rasterization quirks</li>
                    </ul>
                    <p>Dawson exports are:</p>
                    <ul>
                      <li>pure vector geometry</li>
                      <li>metric-independent</li>
                      <li>baseline-baked</li>
                      <li>renderer-neutral</li>
                    </ul>
                    <p>
                      You are not relying on the browser’s font engine.
                      You are working directly with geometry.
                    </p>
                    <p><code>&lt;symbol&gt;</code> is the correct container for that model.</p>
                  </li>
                  <li>
                    <p><strong>Why not just use <code>&lt;g id&gt;</code>?</strong></p>
                    <p>Because <code>&lt;g&gt;</code>:</p>
                    <ul>
                      <li>has no <code>viewBox</code></li>
                      <li>has no intrinsic <code>width</code>/<code>height</code></li>
                      <li>requires transforms for scaling</li>
                      <li>makes layout math dependent on context</li>
                    </ul>
                    <p>That defeats the purpose of deterministic exports.</p>
                    <p>You would be reintroducing the very runtime math the system removes.</p>
                  </li>
                  <li>
                    <p><strong>Can you convert to <code>&lt;g id&gt;</code> or anything else?</strong></p>
                    <p>Yes. Easily. The path data is already fully baked.</p>
                    <p>Every exported file contains:</p>
                    <pre><code>&lt;symbol id="..." viewBox="0 0 W H"&gt;
  &lt;path d="..." /&gt;
&lt;/symbol&gt;</code></pre>
                    <p>If you prefer:</p>
                    <ul>
                      <li><code>&lt;g id="..."&gt;</code></li>
                      <li><code>&lt;path id="..."&gt;</code></li>
                      <li>inline geometry</li>
                      <li>React components</li>
                      <li>CAD ingestion</li>
                      <li>game engine ingestion</li>
                      <li>custom wrappers</li>
                    </ul>
                    <p>You simply change the wrapper.</p>
                    <p>Example conversion:</p>
                    <p>From:</p>
                    <pre><code>&lt;symbol id="glyph" viewBox="0 0 W H"&gt;
  &lt;path d="..." /&gt;
&lt;/symbol&gt;</code></pre>
                    <p>To:</p>
                    <pre><code>&lt;g id="glyph"&gt;
  &lt;path d="..." /&gt;
&lt;/g&gt;</code></pre>
                    <p>
                      The geometry does not change, because the coordinates are already baked.
                      There are no transforms, no paint attributes, and no runtime offsets.
                      The wrapper is just a container.
                    </p>
                  </li>
                  <li>
                    <p><strong>Why <code>&lt;symbol&gt;</code> is the most neutral choice</strong></p>
                    <p><code>&lt;symbol&gt;</code> gives you:</p>
                    <ul>
                      <li>isolation</li>
                      <li>reusability</li>
                      <li>clean instancing</li>
                      <li>scalable viewport logic</li>
                      <li>industry-standard SVG semantics</li>
                    </ul>
                    <p>
                      It is the most structurally correct reusable vector container in SVG.
                      It does not lock you into anything.
                      It does not obscure geometry.
                      It does not add transforms.
                      It simply defines a reusable viewport.
                    </p>
                    <p>That is why Dawson uses it.</p>
                  </li>
                </ol>
                <h3>Summary</h3>
                <p>We use <code>&lt;symbol&gt;</code> because:</p>
                <ul>
                  <li>it provides a deterministic viewport</li>
                  <li>it supports clean instancing with <code>&lt;use&gt;</code></li>
                  <li>it prevents context-dependent scaling math</li>
                  <li>it aligns with modern SVG icon system architecture</li>
                  <li>it keeps glyph geometry self-contained</li>
                </ul>
                <p><strong>And if you ever need something else?</strong></p>
                <p>Change the wrapper. The geometry is already correct.</p>
              </div>
            </details>

            <details>
              <summary>Can I convert the output to a different format?</summary>
              <div class="accordion-body">
                <p>Yes. Easily. The path data is already fully baked.</p>
                <p>Every exported file contains:</p>
                <pre><code>&lt;symbol id="..." viewBox="0 0 W H"&gt;
  &lt;path d="..." /&gt;
&lt;/symbol&gt;</code></pre>
                <p>If you prefer:</p>
                <ul>
                  <li><code>&lt;g id="..."&gt;</code></li>
                  <li><code>&lt;path id="..."&gt;</code></li>
                  <li>inline geometry</li>
                  <li>React components</li>
                  <li>CAD ingestion</li>
                  <li>game engine ingestion</li>
                  <li>custom wrappers</li>
                </ul>
                <p>You simply change the wrapper.</p>
                <p>Example conversion:</p>
                <p>From:</p>
                <pre><code>&lt;symbol id="glyph" viewBox="0 0 W H"&gt;
  &lt;path d="..." /&gt;
&lt;/symbol&gt;</code></pre>
                <p>To:</p>
                <pre><code>&lt;g id="glyph"&gt;
  &lt;path d="..." /&gt;
&lt;/g&gt;</code></pre>
                <p>
                  The geometry does not change, because the coordinates are already baked.
                  There are no transforms, no paint attributes, and no runtime offsets.
                  The wrapper is just a container.
                </p>
              </div>
            </details>
          </div>

          <div class="cta-row cta-row-wide">
            <a class="pill" href="#">More FAQ’s</a>
            <a class="btn btn-dark" href="#">Start Now</a>
          </div>
        </div>
      </div>
    </section>

    <!-- FINAL CTA -->
    <section class="section" id="contact">
      <div class="container">
        <div class="panel final-cta">
          <h2>Ready to run a pass?</h2>
          <div class="cta-row">
            <a class="btn" href="#">Buy / Start</a>
            <a class="btn btn-dark" href="#">Email instead</a>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <div class="panel footer-inner">
        <a class="brand" href="#">
          <img class="brand-logo" src="assets/svg/DAWSON_creative_labs.svg" alt="Dawson Creative Labs"/>
        </a>

        <div class="footer-links">
          <a href="#">Contact</a>
          <span aria-hidden="true">•</span>
          <a href="#">Terms/Refund</a>
          <span aria-hidden="true">•</span>
          <a href="#">Copyright</a>
        </div>

        <a class="btn btn-dark" href="#">Email / Link</a>
      </div>
    </div>
  </footer>
</body>
</html>